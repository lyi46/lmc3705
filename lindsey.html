<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Library Energy Predictor — Weather Reactive</title>
<style>
  /* ---------- Layout: fixed 1920x1080 "canvas" ---------- */
  :root {
    --viewport-w: 1920px;
    --viewport-h: 1080px;
    --card-radius: 22px;
    --accent: #3a6dff;
    --muted: rgba(255,255,255,0.18);
    --glass: rgba(255,255,255,0.30);
  }

  html,body {
    height: 100%;
    margin: 0;
    background: #111;
    font-family: "Inter", "Segoe UI", Roboto, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* center the 1920x1080 viewport */
  .outer {
    width: 100%;
    height: 100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding: 20px;
    box-sizing: border-box;
  }

  .viewport {
    /* prefer the designed 1920x1080 canvas but never exceed the actual browser viewport
       so the top of the page won't be clipped on short windows or mobile devices */
    width: min(var(--viewport-w), 100%);
    height: min(var(--viewport-h), calc(100vh - 40px));
    max-width: 100%;
    max-height: calc(100vh - 40px);
    border-radius: 26px;
    overflow: hidden;
    position: relative;
    background-size: cover;
    background-position: center;
    box-shadow: 0 40px 100px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
  }

  /* colored overlay for readability */
  .bg-overlay {
    position:absolute;
    inset:0;
    background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.48));
    pointer-events:none;
  }

  /* subtle warm pulse overlay (cozy effect) */
  .warm-overlay {
    position:absolute;
    inset:0;
    pointer-events:none;
    background: radial-gradient(circle at 40% 35%, rgba(255,180,120,0.08), transparent 30%);
    mix-blend-mode: screen;
    animation: warmPulse 6s ease-in-out infinite;
    z-index: 1;
  }
  @keyframes warmPulse {
    0% { opacity: 0.6; }
    50% { opacity: 0.9; }
    100% { opacity: 0.6; }
  }

  /* screens (A: form, B: graph) */
  .screen {
    position:absolute;
    inset:0;
    padding: 70px;
    box-sizing: border-box;
    display:flex;
    gap:40px;
    transition: opacity 520ms ease, transform 520ms ease;
    opacity:0;
    transform: translateY(10px);
    pointer-events: none;
  }
  .screen.active {
    opacity:1;
    transform: translateY(0);
    pointer-events: auto;
  }

  /* left column - header */
  .left {
    width: 640px;
    color: #fff;
    display:flex;
    flex-direction:column;
    justify-content:flex-start;
    gap:12px;
  }
  .title {
    font-size:48px;
    font-weight:700;
    line-height:1;
    margin:0;
    letter-spacing:-0.5px;
    text-shadow: 0 6px 20px rgba(0,0,0,0.45);
  }
  .subtitle {
    font-size:18px;
    color: rgba(255,255,255,0.9);
    max-width:520px;
  }

  /* right column - form card */
  .card {
    width: 640px;
    background: linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0.92));
    padding: 28px;
    border-radius: 18px;
    box-shadow: 0 10px 30px rgba(4,8,18,0.25);
    color:#0b1;
    display:flex;
    flex-direction:column;
    gap:14px;
  }
  label {
    font-weight:600;
    font-size:15px;
    color:#1b2a3a;
  }
  select, input[type="time"], input[type="text"] {
    padding:12px 14px;
    border-radius:10px;
    border: 1px solid rgba(15,32,63,0.06);
    font-size:15px;
    outline:none;
    box-sizing: border-box;
    background:white;
  }
  .row {
    display:flex;
    gap:12px;
  }

  .btn {
    margin-top:10px;
    appearance:none;
    border: none;
    background: linear-gradient(90deg,var(--accent), #1f4fff);
    color:white;
    padding:14px 18px;
    font-size:17px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
    box-shadow: 0 8px 30px rgba(58,109,255,0.18);
    transition: transform 160ms ease, box-shadow 160ms ease;
  }
  .btn:hover { transform: translateY(-3px); box-shadow: 0 18px 40px rgba(58,109,255,0.20); }

  /* SCREEN B: graph layout */
  .graph-wrap {
    width: calc(100% - 120px);
    margin: auto;
    display:flex;
    flex-direction:column;
    align-items:stretch;
    gap:18px;
  }
  .graph-top {
    display:flex;
    justify-content:space-between;
    align-items:center;
    color:white;
    padding: 12px 18px;
    background: rgba(0,0,0,0.18);
    border-radius:12px;
    backdrop-filter: blur(6px);
  }
  .meta-left { display:flex; gap:14px; align-items:center; }
  .meta-item { font-size:16px; color: #fff; opacity:0.95; }
  .meta-title { font-weight:700; font-size:20px; }

  /* Chart card */
  .chart-card {
    flex:1;
    background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.92));
    border-radius: 16px;
    padding: 22px;
    box-shadow: 0 16px 40px rgba(2,8,24,0.32);
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  /* chart body with y-axis */
  .chart-body {
    display:flex;
    gap:14px;
    align-items:flex-end;
    width: 100%;
    height: 350px;
  }
  .y-axis {
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    align-items:flex-end;
    min-width:50px;
    color:#2a4360;
    font-size:12px;
    font-weight:600;
    line-height:1;
    padding:6px 6px 2px 0;
    user-select: none;
  }
  .plot-area {
    position:relative;
    flex:1;
  }

  /* timeline area */
  .timeline {
    position:relative;
    height: 440px;
    display:flex;
    align-items:flex-end;
    gap:6px;
  }
  .bar {
    flex: 1;
    border-radius: 8px 8px 0 0;
    background: linear-gradient(180deg, rgba(158,197,255,1), rgba(120,160,255,1));
    transition: height 700ms cubic-bezier(.2,.9,.2,1);
    box-shadow: 0 6px 18px rgba(55,95,200,0.08);
    min-width: 6px;
  }

  /* small timeline label row (30-minute increments) */
  .time-labels {
    display:flex;
    gap:6px;
    margin-top:10px;
    justify-content:space-between;
    align-items:flex-start;
    font-size:11px;
    color:#324a66;
    padding: 0 4px;
    user-select: none;
  }
  .time-label {
    flex: 1;
    text-align: center;
    transform: translateY(0);
    white-space: nowrap;
  }

  /* red dot */
  .red-dot {
    position:absolute;
    width: 18px;
    height: 18px;
    border-radius:50%;
    background: #ff3b3b;
    border: 3px solid #fff;
    transform: translate(-50%, 50%);
    box-shadow: 0 10px 30px rgba(255,59,59,0.24), 0 0 18px rgba(255,59,59,0.12) inset;
    transition: left 900ms cubic-bezier(.2,.9,.2,1), bottom 900ms cubic-bezier(.2,.9,.2,1);
  }

  /* bottom legend */
  .legend {
    display:flex;
    align-items:center;
    justify-content:space-between;
    color:#0b1a2b;
  }

  .small {
    font-size:13px;
    color: #0b1a2b;
  }

  /* back button (top-left in screenB) */
  .back {
    padding: 10px 14px;
    border-radius: 12px;
    border: none;
    background: rgba(0,0,0,0.38);
    color:white;
    cursor:pointer;
    font-weight:700;
    font-size:14px;
  }

  /* small helper */
  .muted {
    color: rgba(255,255,255,0.9);
    opacity: 0.9;
  }

  /* responsiveness (still designed for 1920x1080 but won't break) */
  @media (max-width: 1400px) {
    .viewport { transform: scale(0.8); transform-origin:center; }
    .time-label { font-size:10px; }
  }
</style>
</head>
<body>
  <div class="outer">
    <div id="viewport" class="viewport">
      <div class="bg-overlay"></div>
      <div class="warm-overlay" aria-hidden="true"></div>

      <!-- SCREEN A: the form -->
      <div id="screenA" class="screen active">
        <div class="left">
          <a href="index.html" class="back" style="display:inline-block; margin-bottom:20px; text-decoration:none;">← Back to Index</a>
          <h1 class="title">Library Energy Predictor</h1>
          <div class="subtitle">
            Tell me your study group size and time range — I'll predict energy / occupancy across the period and show you where *you* land.
            The visuals will match current weather to create context and immersion.
          </div>
        </div>

        <div class="card">
          <label>How many people in your party?</label>
          <select id="partySize">
            <option value="1">1</option><option value="2">2</option>
            <option value="3">3</option><option value="4">4</option>
            <option value="5">5+</option>
          </select>

          <div class="row">
            <div style="flex:1">
              <label>From (time)</label>
              <input id="timeFrom" type="time" min="08:00" max="20:00" value="08:00">
            </div>
            <div style="flex:1">
              <label>To (time)</label>
              <input id="timeTo" type="time" min="08:00" max="20:00" value="20:00">
            </div>
          </div>

          <label>Which floor?</label>
          <select id="floor">
            <option>1st Floor</option>
            <option>2nd Floor</option>
            <option>3rd Floor</option>
            <option>Quiet Floor</option>
          </select>

          <div style="display:flex; gap:12px; margin-top:8px;">
            <button id="demoBtn" class="btn" onclick="goToGraph()">See Prediction</button>
            <button id="clearBtn" class="btn" style="background:linear-gradient(90deg,#777,#444)" onclick="resetForm()">Reset</button>
          </div>

          <div style="margin-top:8px; font-size:13px; color:#243447; opacity:0.9;">
            This demo uses OpenWeather forecast + Unsplash to create a photographic background matching the expected conditions at your selected time.
          </div>
        </div>
      </div>

      <!-- SCREEN B: the graph -->
      <div id="screenB" class="screen">
        <div style="width:100%; display:flex; flex-direction:column; gap:18px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="display:flex; gap:14px; align-items:center;">
              <button class="back" onclick="goBack()">← Back</button>
              <div style="color:white; font-weight:700; font-size:18px;" id="screenTitle">Prediction</div>
            </div>

            <div style="display:flex; gap:14px; align-items:center;">
              <div class="muted" id="weatherLabel">Weather</div>
            </div>
          </div>

          <div class="graph-wrap">
            <div class="graph-top">
              <div class="meta-left">
                <div class="meta-item meta-title" id="metaTime">Time Range</div>
                <div class="meta-item" id="metaFloor">Floor</div>
              </div>
              <div class="meta-right">
                <div class="small muted" id="metaParty">Party size</div>
              </div>
            </div>

            <div class="chart-card">
              <div class="chart-body">
                <div class="plot-area">
                  <div id="timeline" class="timeline" aria-hidden="false"></div>
                  <div id="redDot" class="red-dot" style="left:-50px; bottom:0;"></div>
                </div>
              </div>

              <div id="timeLabels" class="time-labels" aria-hidden="false"></div>

              <div class="legend">
                <div class="small">Predicted energy / occupancy (0–100)</div>
                <div class="small" id="dotLabel">You</div>
              </div>
            </div>

          </div>
        </div>
      </div>

    </div>
  </div>

<script>
/*
  WEATHER + UNSPLASH + PSEUDO-LIVE PREDICTION DEMO
  - Replace OPENWEATHER_API_KEY with your own key.
  - For demo we use Georgia Tech coords: lat 33.7756, lon -84.3963
  - Unsplash photographic backgrounds are fetched with the 'source.unsplash.com' endpoint and a weather query.
  - This code simulates predictions using a simple algorithm informed by "weather" and time-of-day patterns.
*/

/* ----------------- CONFIG ----------------- */
const OPENWEATHER_API_KEY = "YOUR_OPENWEATHERMAP_API_KEY"; // <-- REPLACE with your key
const LAT = 33.7756;
const LON = -84.3963;

function toAMPM(timeStr) {
  let [h, m] = timeStr.split(':').map(Number);
  const ampm = h >= 12 ? 'PM' : 'AM';
  h = (h % 12) || 12; // convert 0→12, 13→1, etc.
  return `${h}:${m.toString().padStart(2, '0')} ${ampm}`;
}

function updateLightingImage(fromTime) {
  const img = document.getElementById("lighting-img");  // your image element
  if (!img) {
    console.warn("lighting-img element not found.");
    return;
  }

  // Convert HH:MM → minutes since midnight
  const [h, m] = fromTime.split(":").map(Number);
  const minutes = h * 60 + m;

  // TIME RANGES
  const morningStart = 8 * 60;      // 8:00 AM
  const morningEnd   = 11 * 60;     // 11:00 AM

  const midStart     = 11 * 60 + 1; // 11:01 AM
  const midEnd       = 16 * 60;     // 4:00 PM

  const nightStart   = 16 * 60 + 1; // 4:01 PM
  const nightEnd     = 20 * 60;     // 8:00 PM

  // Apply correct image
  if (minutes >= morningStart && minutes <= morningEnd) {
    img.src = "lm.png";
  } else if (minutes >= midStart && minutes <= midEnd) {
    img.src = "lmid.png";
  } else if (minutes >= nightStart && minutes <= nightEnd) {
    img.src = "ln.png";
  } else {
    console.warn("Start time outside expected range.");
  }
}



/* ----------------- Utilities ----------------- */
function qs(id){ return document.getElementById(id); }
function toMinutes(t){ // "HH:MM" -> minutes since midnight
  if(!t) return 0;
  const [hh,mm] = t.split(":").map(x=>parseInt(x,10));
  return hh*60 + mm;
}
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ----------------- Screen flow ----------------- */
function goToGraph(){
  // read inputs
  const party = qs('partySize').value;
  const from = qs('timeFrom').value;
  const to = qs('timeTo').value;
  const floor = qs('floor').value;

  // basic validation: ensure from < to
  const fMin = toMinutes(from), tMin = toMinutes(to);
  if (fMin===tMin) {
    alert("Please choose a time range where From and To are different.");
    return;
  }
  // enforce allowed window 08:00–20:00
  if (fMin < 8*60 || tMin > 20*60) {
    alert("Please select times between 8:00 AM and 8:00 PM.");
    return;
  }

  // pass metadata to screen B
  qs('metaTime').innerText = `${toAMPM(from)} → ${toAMPM(to)}`;
  updateLightingImage(from);
  qs('metaFloor').innerText = floor;
  qs('metaParty').innerText = `Party size: ${party}`;

  // screen transition
  qs('screenA').classList.remove('active');
  qs('screenB').classList.add('active');

  // compute midpoint time (minutes since midnight) and convert to a Date (today)
  const startMinutes = fMin;
  const totalRange = (tMin > fMin) ? (tMin - fMin) : (tMin + 24*60 - fMin);
  const userMidMinutes = (startMinutes + totalRange/2) % (24*60);

  // create a Date object in local timezone for today with the midpoint time
  const now = new Date();
  const targetDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
  targetDate.setMinutes(userMidMinutes);

  // if midpoint is before now and the range likely meant next day (end < start), adjust by 1 day
  // but our earlier totalRange already handles overnight so targetDate should be correct for today+wrap.
  // For robust results, we will use forecast list and find closest dt (UTC) to this local target date.
  fetchWeatherAndPrepareBackground(targetDate).then(weatherMain => {
    // generate predicted timeline and animate
    generatePredictedTimeline({party, from, to, floor, weatherMain});
  }).catch(err=>{
    console.error(err);
    // fallback: still generate without weather
    generatePredictedTimeline({party, from, to, floor, weatherMain: 'Clear'});
  });
}

function goBack(){
  qs('screenB').classList.remove('active');
  qs('screenA').classList.add('active');

  // reset background
  qs('viewport').style.backgroundImage = '';
  qs('weatherLabel').innerText = '';
  // clear timeline quickly
  qs('timeline').innerHTML = '';
  qs('timeLabels').innerHTML = '';
  qs('redDot').style.left = '-50px';
}

/* ----------------- Weather + Unsplash (CURRENT weather) ----------------- */
/*
  This version fetches the CURRENT weather for Atlanta and chooses an Unsplash photographic query
  that matches the 'main' weather (Clear, Clouds, Rain, Snow, etc.). The function signature is
  kept the same (accepting targetLocalDate) so other calls don't need changes.
*/
async function fetchWeatherAndPrepareBackground(targetLocalDate){
  // targetLocalDate param is ignored for current-weather fetch but kept for compatibility.
  // If API key missing -> fallback immediately
  if (!OPENWEATHER_API_KEY || OPENWEATHER_API_KEY === "YOUR_OPENWEATHERMAP_API_KEY") {
    console.warn("OpenWeatherMap API key not set — using default 'Clouds' for background.");
    applyUnsplashBackgroundFor('Clouds');
    qs('weatherLabel').innerText = 'Clouds (demo)';
    return 'Clouds';
  }

  // use current weather endpoint
  const url = `https://api.openweathermap.org/data/2.5/weather?lat=${LAT}&lon=${LON}&appid=${OPENWEATHER_API_KEY}`;
  try {
    const res = await fetch(url);
    if (!res.ok) {
      console.warn("Weather fetch failed, using default.");
      applyUnsplashBackgroundFor('Clouds');
      qs('weatherLabel').innerText = 'Clouds (fallback)';
      return 'Clouds';
    }
    const json = await res.json();
    const main = (json.weather && json.weather[0] && json.weather[0].main) ? json.weather[0].main : 'Clear';

    // apply background and label
    applyUnsplashBackgroundFor(main);

    // show local time of observation if available
    if (json.dt) {
      const obsDate = new Date(json.dt * 1000);
      const hh = obsDate.toLocaleString(undefined, {hour: 'numeric', minute:'2-digit'});
      qs('weatherLabel').innerText = `${main} • now (${hh})`;
    } else {
      qs('weatherLabel').innerText = `${main}`;
    }

    return main;
  } catch (err) {
    console.error('Weather fetch error:', err);
    applyUnsplashBackgroundFor('Clouds');
    qs('weatherLabel').innerText = 'Clouds (error)';
    return 'Clouds';
  }
}

function applyUnsplashBackgroundFor(weatherMain){
  // Map weather "main" to queries for Unsplash.
  const map = {
    Clear: "sunny+sky,clear+sky,blue+sky",
    Clouds: "cloudy+sky,overcast",
    Rain: "rain,raindrops,wet+window,rainy+city",
    Drizzle: "light+rain,raindrops",
    Thunderstorm: "storm,thunderstorm,stormy+sky",
    Snow: "snow,snowy+landscape",
    Mist: "mist,fog,misty+morning",
    Smoke: "smoky+sky",
    Haze: "hazy+sky",
    Fog: "foggy+landscape",
    Dust: "dusty+landscape"
  };
  const q = map[weatherMain] || "weather,sky";
  // use Unsplash Source to fetch a random photographic image matching the query
  // (1920x1080 requested)
  const unsplashUrl = `https://source.unsplash.com/1920x1080/?${encodeURIComponent(q)}`;
  // apply background with a subtle fade
  const vp = qs('viewport');
  // preload image then set to avoid flicker
  const img = new Image();
  img.onload = () => {
    // apply background image (cover)
    vp.style.backgroundImage = `linear-gradient(rgba(6,12,30,0.24), rgba(6,12,30,0.32)), url("${unsplashUrl}")`;
  };
  img.onerror = () => {
    console.warn("Unsplash image failed — using fallback color.");
    vp.style.backgroundImage = 'linear-gradient(180deg, #10213a, #18305b)';
  };
  img.src = unsplashUrl;
}

/* ----------------- Prediction / Timeline generation ----------------- */
function generatePredictedTimeline({party, from, to, floor, weatherMain}) {
  const container = qs('timeline');
  container.innerHTML = '';

  // produce N samples (24 across the time range -> hourly steps)
  const samples = 13;
  const startMinutes = toMinutes(from);
  const endMinutes = toMinutes(to);

  // normalize direction (if end < start assume next day)
  const totalRange = (endMinutes > startMinutes) ? (endMinutes - startMinutes) : (endMinutes + 24*60 - startMinutes);

  // For the visual timeline we will synthesize a pattern across the chosen time range
  // Algorithm: base sinusoid by time-of-day, modulate by party size and weather.
  const partyFactor = Math.min(1.6, 1 + (Math.max(1,parseInt(party||1)) - 1) * 0.14);
  const weatherBoostMap = {
    Clear: 0.9, Clouds: 1.05, Rain: 1.18, Drizzle:1.12, Thunderstorm:1.25, Snow:1.1, Mist:1.0
  };
  const weatherFactor = weatherBoostMap[weatherMain] || 1.0;

  const midMinutes = (startMinutes + (totalRange/2)) % (24*60);
  const midFrac = midMinutes / (24*60);

  // amplitude baseline (0..100)
  const baseAmp = 36;
  const noiseSeed = Math.random() * 1000;

  // generate array (values correspond to each hourly sample across the selected interval range)
  const values = new Array(samples).fill(0).map((_, i) => {
    const frac = i / (samples - 1); // 0..1 across range
    // map to absolute minutes in day
    const minute = (startMinutes + frac * totalRange) % (24*60);
    const dayFrac = minute / (24*60);

    // sinusoidal daily rhythm (students often peak late afternoon/evening)
    // use cosine to simulate ebb/flow; shift towards selected midpoint
    const rhythm = Math.cos((dayFrac - 0.5) * Math.PI * 2 * 0.75) * 0.5 + 0.5; // 0..1

    // distance from the selected midpoint -> higher near midpoint
    const proximity = Math.max(0, 1 - Math.abs(dayFrac - midFrac) * 3.6);

    // small random noise that is consistent-ish
    const noise = (Math.sin((i + noiseSeed) * 0.78) + Math.random()*0.6) * 6;

    // final composition
    let v = baseAmp * rhythm * (0.9 + 0.9 * proximity) * partyFactor * weatherFactor;
    v += noise;

    // overnight damping: 12:00 AM–6:59 AM keep values low and slightly random
    // produce small values 1..8 so they visually remain low
    if (minute < 7 * 60) {
      v = 1 + Math.random() * 7; // 1–8
    }

    v = clamp(Math.round(v), 1, 98);
    return v;
  });

  // render bars
  const max = Math.max(...values);
  values.forEach(v => {
    const bar = document.createElement('div');
    bar.className = 'bar';
    // set initial small height and animate to height for smoother entrance
    bar.style.height = '4px';
    container.appendChild(bar);
    // animate to final height after a frame
    requestAnimationFrame(() => {
      bar.style.height = (v / 100 * 100) + '%';
    });
  });

  // generate bottom labels for every hour (12:00 AM -> 11:00 PM)
  populateTimeLabels(); // uses 24 labels

  // compute selected "you" position between start & end
  // We'll take the user's "from" time as the start and place the red dot at a representative time:
  // We choose the midpoint of user's requested interval for the "you" marker.
  const userMidMinutes = (startMinutes + totalRange/2) % (24*60);
  const fracOfRange = ((userMidMinutes - startMinutes + 24*60) % (24*60)) / totalRange;
  const indexFloat = fracOfRange * (values.length - 1);
  const index = Math.round(indexFloat);
  const dot = qs('redDot');

  // position the dot above the selected bar, animate into place
  // compute left: find left offset of the bar element
  // after bars are laid out (next frame)
  requestAnimationFrame(() => {
    const bars = container.querySelectorAll('.bar');
    if (!bars || bars.length === 0) {
      dot.style.left = '-50px';
      return;
    }
    const targetBar = bars[index];
    const rect = targetBar.getBoundingClientRect();
    const parentRect = container.getBoundingClientRect();
    // compute center position relative to parent
    const leftPx = (rect.left + rect.right) / 2 - parentRect.left;
    const leftPercent = (leftPx / parentRect.width) * 100;
    const bottomPercent = values[index];

    dot.style.left = leftPercent + '%';
    dot.style.bottom = bottomPercent + '%';
    // add a little pulse animation
    dot.animate([
      { transform: 'translate(-50%, 50%) scale(0.9)', opacity: 0.95 },
      { transform: 'translate(-50%, 50%) scale(1.12)', opacity: 1 },
      { transform: 'translate(-50%, 50%) scale(1.0)', opacity: 1 }
    ], { duration: 900, easing: 'cubic-bezier(.2,.9,.2,1)' });
  });

  // label the chart and dot
  qs('dotLabel').innerText = `You · ≈ ${values[index]}% energy/occupancy`;
}

/* ----------------- Time labels helper ----------------- */
function populateTimeLabels(){
  const container = qs('timeLabels');
  container.innerHTML = '';
  // show hourly labels from 8:00 AM to 8:00 PM
  for (let minutes = 8 * 60; minutes <= 20 * 60; minutes += 60) {
    const hh = Math.floor(minutes / 60);
    const mm = minutes % 60;
    const period = hh < 12 ? 'AM' : 'PM';
    const hour12 = ((hh + 11) % 12) + 1;
    const labelText = `${(mm===0) ? (hour12 + (hour12 === 12 ? '' : '')) : (hour12 + ':' + String(mm).padStart(2,'0'))}${period}`;
    const el = document.createElement('div');
    el.className = 'time-label';
    el.innerText = labelText;
    container.appendChild(el);
  }
}

/*******************************************************
 * YOUR EXISTING CODE — UNCHANGED
 *******************************************************/

// all your existing variables, sliders, DOM setup, bars, 
// student activity logic, questionnaire, graph generation, etc.
// (I am not touching any of your existing logic at all.)

// I am only adding a weather.gov fetch near the bottom where you set the image.


/*******************************************************
 * WEATHER.GOV — DYNAMIC WEATHER ICON FOR ATLANTA
 *******************************************************/

// 1. Fetch the gridpoint for Atlanta
// Coordinates used: Atlanta, GA = 33.7490, -84.3880
fetch("https://api.weather.gov/points/33.7490,-84.3880")
  .then(response => response.json())
  .then(pointData => {
    if (!pointData.properties || !pointData.properties.forecast) {
      console.error("Weather.gov: No forecast URL found for this location.");
      return;
    }

    const forecastURL = pointData.properties.forecast;

    // 2. Fetch the forecast periods (14 total)
    return fetch(forecastURL);
  })
  .then(response => response.json())
  .then(forecastData => {
    if (!forecastData.properties || !forecastData.properties.periods) {
      console.error("Weather.gov: No periods found in forecast data.");
      return;
    }

    const periods = forecastData.properties.periods;

    // 3. The "current period" is always periods[0]
    const current = periods[0];

    // This is the dynamic icon Weather.gov provides
    const iconURL = current.icon;

    // 4. Put the icon into your image element
    // MAKE SURE you have an <img id="weather-img"> in your HTML
    const img = document.getElementById("weather-img");
    if (img) {
      img.src = iconURL;
      img.alt = current.shortForecast || "Weather";
    } else {
      console.warn("weather-img element not found in the DOM.");
    }
  })
  .catch(err => {
    console.error("Weather.gov fetch error:", err);
  });


/*******************************************************
 * END — Everything else in your file stays exactly the same
 *******************************************************/


/* ----------------- Helpers ----------------- */
function resetForm(){
  qs('partySize').value = '1';
  qs('timeFrom').value = '08:00';
  qs('timeTo').value = '20:00';
  qs('floor').value = '1st Floor';
}

/* ----------------- Demo note ----------------- */
// For local testing without an API key, demo still runs but uses a default photographic query (Clouds).
// To use live weather, sign up at https://openweathermap.org/ and put your API key in OPENWEATHER_API_KEY.
// In production, put the key behind a server endpoint to avoid leaking it client-side.

</script>
</body>
</html>
