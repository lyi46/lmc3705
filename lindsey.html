<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Library Energy Predictor — Weather Reactive</title>
<style>
  /* ---------- Layout: fixed 1920x1080 "canvas" ---------- */
  :root {
    --viewport-w: 1920px;
    --viewport-h: 1080px;
    --card-radius: 22px;
    --accent: #3a6dff;
    --muted: rgba(255,255,255,0.18);
    --glass: rgba(255,255,255,0.30);
  }

  html,body {
    height: 100%;
    margin: 0;
    background: #111;
    font-family: "Inter", "Segoe UI", Roboto, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* center the 1920x1080 viewport */
  .outer {
    width: 100%;
    height: 100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding: 20px;
    box-sizing: border-box;
  }

  .viewport {
    /* prefer the designed 1920x1080 canvas but never exceed the actual browser viewport
       so the top of the page won't be clipped on short windows or mobile devices */
    width: min(var(--viewport-w), 100%);
    height: min(var(--viewport-h), calc(100vh - 40px));
    max-width: 100%;
    max-height: calc(100vh - 40px);
    border-radius: 26px;
    overflow: hidden;
    position: relative;
    background-size: cover;
    background-position: center;
    box-shadow: 0 40px 100px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
  }

  /* colored overlay for readability */
  .bg-overlay {
    position:absolute;
    inset:0;
    background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.48));
    pointer-events:none;
  }

  /* subtle warm pulse overlay (cozy effect) */
  .warm-overlay {
    position:absolute;
    inset:0;
    pointer-events:none;
    background: radial-gradient(circle at 40% 35%, rgba(255,180,120,0.08), transparent 30%);
    mix-blend-mode: screen;
    animation: warmPulse 6s ease-in-out infinite;
    z-index: 1;
  }
  @keyframes warmPulse {
    0% { opacity: 0.6; }
    50% { opacity: 0.9; }
    100% { opacity: 0.6; }
  }

  /* screens (A: form, B: graph) */
  .screen {
    position:absolute;
    inset:0;
    padding: 70px;
    box-sizing: border-box;
    display:flex;
    gap:40px;
    transition: opacity 520ms ease, transform 520ms ease;
    opacity:0;
    transform: translateY(10px);
    pointer-events: none;
  }
  .screen.active {
    opacity:1;
    transform: translateY(0);
    pointer-events: auto;
  }

  /* left column - header */
  .left {
    width: 640px;
    color: #fff;
    display:flex;
    flex-direction:column;
    justify-content:flex-start;
    gap:12px;
  }
  .title {
    font-size:48px;
    font-weight:700;
    line-height:1;
    margin:0;
    letter-spacing:-0.5px;
    text-shadow: 0 6px 20px rgba(0,0,0,0.45);
  }
  .subtitle {
    font-size:18px;
    color: rgba(255,255,255,0.9);
    max-width:520px;
  }

  /* right column - form card */
  .card {
    width: 640px;
    background: linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0.92));
    padding: 28px;
    border-radius: 18px;
    box-shadow: 0 10px 30px rgba(4,8,18,0.25);
    color:#0b1;
    display:flex;
    flex-direction:column;
    gap:14px;
  }
  label {
    font-weight:600;
    font-size:15px;
    color:#1b2a3a;
  }
  select, input[type="time"], input[type="text"] {
    padding:12px 14px;
    border-radius:10px;
    border: 1px solid rgba(15,32,63,0.06);
    font-size:15px;
    outline:none;
    box-sizing: border-box;
    background:white;
  }
  .row {
    display:flex;
    gap:12px;
  }

  .btn {
    margin-top:10px;
    appearance:none;
    border: none;
    background: linear-gradient(90deg,var(--accent), #1f4fff);
    color:white;
    padding:14px 18px;
    font-size:17px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
    box-shadow: 0 8px 30px rgba(58,109,255,0.18);
    transition: transform 160ms ease, box-shadow 160ms ease;
  }
  .btn:hover { transform: translateY(-3px); box-shadow: 0 18px 40px rgba(58,109,255,0.20); }

  /* SCREEN B: graph layout */
  .graph-wrap {
    width: calc(100% - 120px);
    margin: auto;
    display:flex;
    flex-direction:column;
    align-items:stretch;
    gap:18px;
  }
  .graph-top {
    display:flex;
    justify-content:space-between;
    align-items:center;
    color:white;
    padding: 12px 18px;
    background: rgba(0,0,0,0.18);
    border-radius:12px;
    backdrop-filter: blur(6px);
  }
  .meta-left { display:flex; gap:14px; align-items:center; }
  .meta-item { font-size:16px; color: #fff; opacity:0.95; }
  .meta-title { font-weight:700; font-size:20px; }

  /* Chart card */
  .chart-card {
    flex:1;
    background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.92));
    border-radius: 16px;
    padding: 22px;
    box-shadow: 0 16px 40px rgba(2,8,24,0.32);
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  /* chart body with y-axis */
  .chart-body {
    display:flex;
    gap:14px;
    align-items:flex-end;
    width: 100%;
    height: 300px;
  }
  .y-axis {
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    align-items:flex-end;
    min-width:50px;
    color:#2a4360;
    font-size:12px;
    font-weight:600;
    line-height:1;
    padding:6px 6px 2px 0;
    user-select: none;
  }
  .plot-area {
    position:relative;
    flex:1;
  }

  /* timeline area */
  .timeline {
    position:relative;
    height: 440px;
    display:flex;
    align-items:flex-end;
    gap:6px;
  }
  .bar {
    flex: 1;
    border-radius: 8px 8px 0 0;
    background: linear-gradient(180deg, rgba(158,197,255,1), rgba(120,160,255,1));
    transition: height 700ms cubic-bezier(.2,.9,.2,1);
    box-shadow: 0 6px 18px rgba(55,95,200,0.08);
    min-width: 6px;
  }

  /* small timeline label row (30-minute increments) */
  .time-labels {
    display:flex;
    gap:6px;
    margin-top:10px;
    justify-content:space-between;
    align-items:flex-start;
    font-size:11px;
    color:#324a66;
    padding: 0 4px;
    user-select: none;
  }
  .time-label {
    flex: 1;
    text-align: center;
    transform: translateY(0);
    white-space: nowrap;
  }

  /* red dot */
  .red-dot {
    position:absolute;
    width: 18px;
    height: 18px;
    border-radius:50%;
    background: #ff3b3b;
    border: 3px solid #fff;
    transform: translate(-50%, 50%);
    box-shadow: 0 10px 30px rgba(255,59,59,0.24), 0 0 18px rgba(255,59,59,0.12) inset;
    transition: left 900ms cubic-bezier(.2,.9,.2,1), bottom 900ms cubic-bezier(.2,.9,.2,1);
  }

  /* bottom legend */
  .legend {
    display:flex;
    align-items:center;
    justify-content:space-between;
    color:#0b1a2b;
  }

  .small {
    font-size:13px;
    color: #0b1a2b;
  }

  /* back button (top-left in screenB) */
  .back {
    padding: 10px 14px;
    border-radius: 12px;
    border: none;
    background: rgba(0,0,0,0.38);
    color:white;
    cursor:pointer;
    font-weight:700;
    font-size:14px;
  }

  /* small helper */
  .muted {
    color: rgba(255,255,255,0.9);
    opacity: 0.9;
  }

  /* responsiveness (still designed for 1920x1080 but won't break) */
  @media (max-width: 1400px) {
    .viewport { transform: scale(0.8); transform-origin:center; }
    .time-label { font-size:10px; }
  }
</style>
</head>
<body>
  <div class="outer">
    <div id="viewport" class="viewport">
      <div class="bg-overlay"></div>
      <div class="warm-overlay" aria-hidden="true"></div>

      <!-- SCREEN A: the form -->
      <div id="screenA" class="screen active">
        <div class="left">
          <a href="index.html" class="back" style="display:inline-block; margin-bottom:20px; text-decoration:none;">← Back to Index</a>
          <h1 class="title">Library Energy Predictor</h1>
          <div class="subtitle">
            Tell me your study group size and time range — I'll predict energy / occupancy across the period and show you where *you* land.
            The visuals will match current weather to create context and immersion.
          </div>
        </div>

        <div class="card">
          <label>How many people in your party?</label>
          <select id="partySize">
            <option value="1">1</option><option value="2">2</option>
            <option value="3">3</option><option value="4">4</option>
            <option value="5">5+</option>
          </select>

          <div class="row">
            <div style="flex:1">
              <label>From (time)</label>
              <input id="timeFrom" type="time" value="18:00">
            </div>
            <div style="flex:1">
              <label>To (time)</label>
              <input id="timeTo" type="time" value="20:00">
            </div>
          </div>

          <label>Which floor?</label>
          <select id="floor">
            <option>1st Floor</option>
            <option>2nd Floor</option>
            <option>3rd Floor</option>
            <option>Quiet Floor</option>
          </select>

          <div style="display:flex; gap:12px; margin-top:8px;">
            <button id="demoBtn" class="btn" onclick="goToGraph()">See Prediction</button>
            <button id="clearBtn" class="btn" style="background:linear-gradient(90deg,#777,#444)" onclick="resetForm()">Reset</button>
          </div>

          <div style="margin-top:8px; font-size:13px; color:#243447; opacity:0.9;">
            This demo uses OpenWeather forecast + Unsplash to create a photographic background matching the expected conditions at your selected time.
          </div>
        </div>
      </div>

      <!-- SCREEN B: the graph -->
      <div id="screenB" class="screen">
        <div style="width:100%; display:flex; flex-direction:column; gap:18px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="display:flex; gap:14px; align-items:center;">
              <button class="back" onclick="goBack()">← Back</button>
              <div style="color:white; font-weight:700; font-size:18px;" id="screenTitle">Prediction</div>
            </div>

            <div style="display:flex; gap:14px; align-items:center;">
              <div class="muted" id="weatherLabel">Weather</div>
            </div>
          </div>

          <div class="graph-wrap">
            <div class="graph-top">
              <div class="meta-left">
                <div class="meta-item meta-title" id="metaTime">Time Range</div>
                <div class="meta-item" id="metaFloor">Floor</div>
              </div>
              <div class="meta-right">
                <div class="small muted" id="metaParty">Party size</div>
              </div>
            </div>

            <div class="chart-card">
              <div class="chart-body">
                <div class="plot-area">
                  <div id="timeline" class="timeline" aria-hidden="false"></div>
                  <div id="redDot" class="red-dot" style="left:-50px; bottom:0;"></div>
                </div>
              </div>

              <div id="timeLabels" class="time-labels" aria-hidden="false"></div>

              <div class="legend">
                <div class="small">Predicted energy / occupancy (0–100)</div>
                <div class="small" id="dotLabel">You</div>
              </div>
            </div>

          </div>
        </div>
      </div>

    </div>
  </div>

<script>
/*
  WEATHER + UNSPLASH + PSEUDO-LIVE PREDICTION DEMO
  - Replace OPENWEATHER_API_KEY with your own key.
  - For demo we use Georgia Tech coords: lat 33.7756, lon -84.3963
  - Unsplash photographic backgrounds are fetched with the 'source.unsplash.com' endpoint and a weather query.
  - This code simulates predictions using a simple algorithm informed by "weather" and time-of-day patterns.
*/

/* ----------------- CONFIG ----------------- */
const OPENWEATHER_API_KEY = "YOUR_OPENWEATHERMAP_API_KEY"; // <-- REPLACE with your key
const LAT = 33.7756;
const LON = -84.3963;

/* ----------------- Utilities ----------------- */
function qs(id){ return document.getElementById(id); }
function toMinutes(t){ // "HH:MM" -> minutes since midnight
  if(!t) return 0;
  const [hh,mm] = t.split(":").map(x=>parseInt(x,10));
  return hh*60 + mm;
}
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ----------------- Screen flow ----------------- */
function goToGraph(){
  // read inputs
  const party = qs('partySize').value;
  const from = qs('timeFrom').value;
  const to = qs('timeTo').value;
  const floor = qs('floor').value;

  // basic validation: ensure from < to
  const fMin = toMinutes(from), tMin = toMinutes(to);
  if (fMin===tMin) {
    alert("Please choose a time range where From and To are different.");
    return;
  }

  // pass metadata to screen B
  qs('metaTime').innerText = `${from} → ${to}`;
  qs('metaFloor').innerText = floor;
  qs('metaParty').innerText = `Party size: ${party}`;

  // screen transition
  qs('screenA').classList.remove('active');
  qs('screenB').classList.add('active');

  // compute midpoint time (minutes since midnight) and convert to a Date (today)
  const startMinutes = fMin;
  const totalRange = (tMin > fMin) ? (tMin - fMin) : (tMin + 24*60 - fMin);
  const userMidMinutes = (startMinutes + totalRange/2) % (24*60);

  // create a Date object in local timezone for today with the midpoint time
  const now = new Date();
  const targetDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
  targetDate.setMinutes(userMidMinutes);

  // if midpoint is before now and the range likely meant next day (end < start), adjust by 1 day
  // but our earlier totalRange already handles overnight so targetDate should be correct for today+wrap.
  // For robust results, we will use forecast list and find closest dt (UTC) to this local target date.
  fetchWeatherAndPrepareBackground(targetDate).then(weatherMain => {
    // generate predicted timeline and animate
    generatePredictedTimeline({party, from, to, floor, weatherMain});
  }).catch(err=>{
    console.error(err);
    // fallback: still generate without weather
    generatePredictedTimeline({party, from, to, floor, weatherMain: 'Clear'});
  });
}

function goBack(){
  qs('screenB').classList.remove('active');
  qs('screenA').classList.add('active');

  // reset background
  qs('viewport').style.backgroundImage = '';
  qs('weatherLabel').innerText = '';
  // clear timeline quickly
  qs('timeline').innerHTML = '';
  qs('timeLabels').innerHTML = '';
  qs('redDot').style.left = '-50px';
}

/* ----------------- Weather + Unsplash (forecast-aware) ----------------- */
/*
  We'll use OpenWeather 5-day / 3-hour forecast endpoint:
  https://api.openweathermap.org/data/2.5/forecast?lat={lat}&lon={lon}&appid={API key}
  The "list" contains items with dt (UTC seconds) roughly every 3 hours.
  We'll find the forecast item whose dt is closest to the target timestamp.
*/
async function fetchWeatherAndPrepareBackground(targetLocalDate){
  // targetLocalDate: JS Date in user's local timezone (America/New_York assumed).
  // Convert to epoch seconds (UTC) for comparison with forecast dt.
  const targetEpochSec = Math.floor(targetLocalDate.getTime() / 1000);

  // If API key missing -> fallback immediately
  if (!OPENWEATHER_API_KEY || OPENWEATHER_API_KEY === "YOUR_OPENWEATHERMAP_API_KEY") {
    console.warn("OpenWeatherMap API key not set — using default 'Clouds' for background.");
    applyUnsplashBackgroundFor('Clouds');
    qs('weatherLabel').innerText = 'Clouds (demo)';
    return 'Clouds';
  }

  const url = `https://api.openweathermap.org/data/2.5/forecast?lat=${LAT}&lon=${LON}&appid=${OPENWEATHER_API_KEY}`;
  try {
    const res = await fetch(url);
    if (!res.ok) {
      console.warn("Weather fetch failed, using default.");
      applyUnsplashBackgroundFor('Clouds');
      qs('weatherLabel').innerText = 'Clouds (fallback)';
      return 'Clouds';
    }
    const json = await res.json();
    if (!json.list || !Array.isArray(json.list) || json.list.length === 0) {
      applyUnsplashBackgroundFor('Clouds');
      qs('weatherLabel').innerText = 'Clouds (no forecast)';
      return 'Clouds';
    }

    // find the forecast entry with dt closest to our targetEpochSec
    let best = json.list[0];
    let bestDiff = Math.abs(best.dt - targetEpochSec);
    for (let item of json.list) {
      const diff = Math.abs(item.dt - targetEpochSec);
      if (diff < bestDiff) {
        best = item;
        bestDiff = diff;
      }
    }
    const main = (best.weather && best.weather[0] && best.weather[0].main) ? best.weather[0].main : 'Clear';
    applyUnsplashBackgroundFor(main);
    // optional: show more informative label including time of the forecast we used
    const forecastDate = new Date(best.dt * 1000);
    const hh = forecastDate.toLocaleString(undefined, {hour: 'numeric', minute:'2-digit'});
    qs('weatherLabel').innerText = `${main} • forecast ${hh}`;
    return main;
  } catch (err) {
    console.error('Weather fetch error:', err);
    applyUnsplashBackgroundFor('Clouds');
    qs('weatherLabel').innerText = 'Clouds (error)';
    return 'Clouds';
  }
}

function applyUnsplashBackgroundFor(weatherMain){
  // Map weather "main" to queries for Unsplash.
  const map = {
    Clear: "sunny+sky,clear+sky,blue+sky",
    Clouds: "cloudy+sky,overcast",
    Rain: "rain,raindrops,wet+window,rainy+city",
    Drizzle: "light+rain,raindrops",
    Thunderstorm: "storm,thunderstorm,stormy+sky",
    Snow: "snow,snowy+landscape",
    Mist: "mist,fog,misty+morning",
    Smoke: "smoky+sky",
    Haze: "hazy+sky",
    Fog: "foggy+landscape",
    Dust: "dusty+landscape"
  };
  const q = map[weatherMain] || "weather,sky";
  // use Unsplash Source to fetch a random photographic image matching the query
  // (1920x1080 requested)
  const unsplashUrl = `https://source.unsplash.com/1920x1080/?${encodeURIComponent(q)}`;
  // apply background with a subtle fade
  const vp = qs('viewport');
  // preload image then set to avoid flicker
  const img = new Image();
  img.onload = () => {
    // apply background image (cover)
    vp.style.backgroundImage = `linear-gradient(rgba(6,12,30,0.24), rgba(6,12,30,0.32)), url("${unsplashUrl}")`;
  };
  img.onerror = () => {
    console.warn("Unsplash image failed — using fallback color.");
    vp.style.backgroundImage = 'linear-gradient(180deg, #10213a, #18305b)';
  };
  img.src = unsplashUrl;
}

/* ----------------- Prediction / Timeline generation ----------------- */
function generatePredictedTimeline({party, from, to, floor, weatherMain}) {
  const container = qs('timeline');
  container.innerHTML = '';

  // produce N samples (24 across the time range -> hourly steps)
  const samples = 24;
  const startMinutes = toMinutes(from);
  const endMinutes = toMinutes(to);

  // normalize direction (if end < start assume next day)
  const totalRange = (endMinutes > startMinutes) ? (endMinutes - startMinutes) : (endMinutes + 24*60 - startMinutes);

  // For the visual timeline we will synthesize a pattern across the chosen time range
  // Algorithm: base sinusoid by time-of-day, modulate by party size and weather.
  const partyFactor = Math.min(1.6, 1 + (Math.max(1,parseInt(party||1)) - 1) * 0.14);
  const weatherBoostMap = {
    Clear: 0.9, Clouds: 1.05, Rain: 1.18, Drizzle:1.12, Thunderstorm:1.25, Snow:1.1, Mist:1.0
  };
  const weatherFactor = weatherBoostMap[weatherMain] || 1.0;

  const midMinutes = (startMinutes + (totalRange/2)) % (24*60);
  const midFrac = midMinutes / (24*60);

  // amplitude baseline (0..100)
  const baseAmp = 36;
  const noiseSeed = Math.random() * 1000;

  // generate array (values correspond to each hourly sample across the selected interval range)
  const values = new Array(samples).fill(0).map((_, i) => {
    const frac = i / (samples - 1); // 0..1 across range
    // map to absolute minutes in day
    const minute = (startMinutes + frac * totalRange) % (24*60);
    const dayFrac = minute / (24*60);

    // sinusoidal daily rhythm (students often peak late afternoon/evening)
    // use cosine to simulate ebb/flow; shift towards selected midpoint
    const rhythm = Math.cos((dayFrac - 0.5) * Math.PI * 2 * 0.75) * 0.5 + 0.5; // 0..1

    // distance from the selected midpoint -> higher near midpoint
    const proximity = Math.max(0, 1 - Math.abs(dayFrac - midFrac) * 3.6);

    // small random noise that is consistent-ish
    const noise = (Math.sin((i + noiseSeed) * 0.78) + Math.random()*0.6) * 6;

    // final composition
    let v = baseAmp * rhythm * (0.9 + 0.9 * proximity) * partyFactor * weatherFactor;
    v += noise;

    // overnight damping: 12:00 AM–6:59 AM keep values low and slightly random
    if (minute < 7 * 60) {
      v = Math.random() * 0.001; // roughly 6–14 for very low overnight activity
    }

    v = clamp(Math.round(v), 1, 98);
    return v;
  });

  // render bars
  const max = Math.max(...values);
  values.forEach(v => {
    const bar = document.createElement('div');
    bar.className = 'bar';
    // set initial small height and animate to height for smoother entrance
    bar.style.height = '4px';
    container.appendChild(bar);
    // animate to final height after a frame
    requestAnimationFrame(() => {
      bar.style.height = (v / 100 * 100) + '%';
    });
  });

  // generate bottom labels for every hour (12:00 AM -> 11:00 PM)
  populateTimeLabels(); // uses 24 labels

  // compute selected "you" position between start & end
  // We'll take the user's "from" time as the start and place the red dot at a representative time:
  // We choose the midpoint of user's requested interval for the "you" marker.
  const userMidMinutes = (startMinutes + totalRange/2) % (24*60);
  const fracOfRange = ((userMidMinutes - startMinutes + 24*60) % (24*60)) / totalRange;
  const indexFloat = fracOfRange * (values.length - 1);
  const index = Math.round(indexFloat);
  const dot = qs('redDot');

  // position the dot above the selected bar, animate into place
  // compute left: find left offset of the bar element
  // after bars are laid out (next frame)
  requestAnimationFrame(() => {
    const bars = container.querySelectorAll('.bar');
    if (!bars || bars.length === 0) {
      dot.style.left = '-50px';
      return;
    }
    const targetBar = bars[index];
    const rect = targetBar.getBoundingClientRect();
    const parentRect = container.getBoundingClientRect();
    // compute center position relative to parent
    const leftPx = (rect.left + rect.right) / 2 - parentRect.left;
    const leftPercent = (leftPx / parentRect.width) * 100;
    const bottomPercent = values[index];

    dot.style.left = leftPercent + '%';
    dot.style.bottom = bottomPercent + '%';
    // add a little pulse animation
    dot.animate([
      { transform: 'translate(-50%, 50%) scale(0.9)', opacity: 0.95 },
      { transform: 'translate(-50%, 50%) scale(1.12)', opacity: 1 },
      { transform: 'translate(-50%, 50%) scale(1.0)', opacity: 1 }
    ], { duration: 900, easing: 'cubic-bezier(.2,.9,.2,1)' });
  });

  // label the chart and dot
  qs('dotLabel').innerText = `You · ≈ ${values[index]}% energy/occupancy`;
}

/* ----------------- Time labels helper ----------------- */
function populateTimeLabels(){
  const container = qs('timeLabels');
  container.innerHTML = '';
  for (let minutes = 0; minutes <= 23 * 60; minutes += 60) {
    const hh = Math.floor(minutes / 60);
    const mm = minutes % 60;
    const period = hh < 12 ? 'AM' : 'PM';
    const hour12 = ((hh + 11) % 12) + 1;
    const labelText = `${(mm===0) ? (hour12 + (hour12 === 12 ? '' : '')) : (hour12 + ':' + String(mm).padStart(2,'0'))}${period}`;
    const el = document.createElement('div');
    el.className = 'time-label';
    el.innerText = labelText;
    container.appendChild(el);
  }
}

/* ----------------- Helpers ----------------- */
function resetForm(){
  qs('partySize').value = '1';
  qs('timeFrom').value = '18:00';
  qs('timeTo').value = '20:00';
  qs('floor').value = '1st Floor';
}

/* ----------------- Demo note ----------------- */
// For local testing without an API key, demo still runs but uses a default photographic query (Clouds).
// To use live weather, sign up at https://openweathermap.org/ and put your API key in OPENWEATHER_API_KEY.
// In production, put the key behind a server endpoint to avoid leaking it client-side.

</script>
</body>
</html>
